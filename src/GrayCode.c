#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "utilities.h"
#include "Zaks.h"
#include "Sjt.h"
#include "Heaps.h"
#include "lexicographic.h"
#include "ladder.h"
#include "GrayCode.h"
#include "LinkedListAPI.h"

void grayCodeDriver(int n)
{
    //step 1: generate permutations of size N with
    //the four different algorithms

    //all perms generated by SJT algorithm
    int **sjtPerms = sjtGrayCodeDriver(n);

    //all perms generated by Heap's algorithm
    int **heapsPerms = heapsGrayCodeDriver(n);

    //all  perms generated by Zak's algorithm
    int **zaksPerms = zaksGrayCodeDriver(n);

    //all perms generated by lexicographic algorithm
    int **lexPerms = lexGrayCodeDriver(n);

    //generate all the ladders from the permutations
    List *sjtLadders = genCanonicalLadders(sjtPerms, n);

    List *heapsLadders = genCanonicalLadders(heapsPerms, n);
    ;
    List *zaksLadders = genCanonicalLadders(zaksPerms, n);
    ;
    List *lexLadders = genCanonicalLadders(lexPerms, n);

    // printAllLadders(sjtLadders);

    // printAllLadders(heapsLadders);
    //printAllLadders(zaksLadders);
    //printAllLadders(lexLadders);

    getMinChangeDifferential(heapsLadders);

    //freeMem
    forall(factorial(n))
    {
        free(sjtPerms[x]);
        free(heapsPerms[x]);
        free(zaksPerms[x]);
        free(lexPerms[x]);
    }
    free(sjtPerms);
    free(heapsPerms);
    free(zaksPerms);
    free(lexPerms);
    freeList(sjtLadders);
    freeList(heapsLadders);
    freeList(zaksLadders);
    freeList(lexLadders);
}

int **sjtGrayCodeDriver(int n)
{
    //set up the variables
    int *perm = calloc(n, sizeof(int));
    int *arr = calloc(n, sizeof(int));
    bool *direction = calloc(n, sizeof(int));
    forall(n)
    {
        perm[x] = x + 1;
        arr[x] = 0;
        direction[x] = false;
    }

    int **perms = calloc(factorial(n), sizeof(int *));
    forall(factorial(n)) perms[x] = NULL;

    //call the algo
    genPermsSJT(perms, perm, n, arr, direction);

    //free the mem
    free(perm);
    free(arr);
    free(direction);

    return perms;
}

int **heapsGrayCodeDriver(int n)
{
    //set up the perms
    int **perms = calloc(factorial(n), sizeof(int *));
    int *perm = calloc(n, sizeof(int));
    forall(n) perm[x] = x + 1;
    forall(factorial(n)) perms[x] = NULL;

    //call the algo
    heaps(perms, perm, n, n);

    //return
    free(perm);
    return perms;
}

int **zaksGrayCodeDriver(int n)
{
    //allocate for the suffix sizes
    int *suffixSizes = calloc(1000000, sizeof(int));
    forall(1000000) suffixSizes[x] = -1;

    //set the suffix sizes
    suffixSize(n, suffixSizes);

    //create + set the perm, perms
    int *perm = calloc(n, sizeof(int));
    int **perms = calloc(factorial(n), sizeof(int *));
    forall(factorial(n)) perms[x] = NULL;
    forall(n) perm[x] = x + 1;

    //call the algo
    zaks(perms, perm, n, suffixSizes, 0);

    //free mem
    free(suffixSizes);
    free(perm);
    return perms;
}

int **lexGrayCodeDriver(int n)
{
    //set up the variables
    int *perm = calloc(n, sizeof(int));
    forall(n) perm[x] = x + 1;
    new_object(int **, perms, factorial(n));
    forall(factorial(n)) perms[x] = NULL;

    //call the algo
    orderedPerms(perms, perm, factorial(n), 1, n);
    free(perm);

    //return
    return perms;
}

//Ladder Driver
List *genCanonicalLadders(int **perms, int n)
{
    List *ladders = initializeList(dummy_print, destroyLadder, dummy_compare);

    forall(factorial(n))
    {

        Ladder *l = newLadder(n);
        initLadder(l);
        createRoot(l, perms[x], n, 0);
        l->ladderNumber = x + 1;
        insertBack(ladders, l);
    }
    return ladders;
}

int calMinChangeDifferential(Bar **firstBars, Bar **secondBars, int lenOne, int lenTwo)
{
    int numDiff = 0;
    if (lenOne == 0)
        return lenTwo - lenOne;
    if (lenTwo == 0)
        return lenOne - lenTwo;
    bool flag = false;
   
   
    //go through first array of bars
    for (int i = 0; i < lenOne; i++)
    {
        //get the bar
        Bar *b1 = firstBars[i];

        //go through second array of bars
        for (int j = 0; j < lenTwo; j++)
        {
            //et the bar
            Bar *b2 = secondBars[j];

            //if they are the same, then there is no difference between b1 and b2.
            if (b1->vals[0] == b2->vals[0] && b1->vals[1] == b2->vals[1])
            {
                flag = true;
                break;
            }
        }
        //if there was no matching bar, b2, with b1, then there is a difference
        if (!(flag))
        {
            numDiff++;
        }
        //reset the flag
        flag = false;
    }

      //go through first array of bars
    for (int i = 0; i < lenTwo; i++)
    {
        //get the bar
        Bar *b1 = secondBars[i];

        //go through second array of bars
        for (int j = 0; j < lenOne; j++)
        {
            //et the bar
            Bar *b2 = firstBars[j];

            //if they are the same, then there is no difference between b1 and b2.
            if (b1->vals[0] == b2->vals[0] && b1->vals[1] == b2->vals[1])
            {
                flag = true;
                break;
            }
        }
        //if there was no matching bar, b2, with b1, then there is a difference
        if (!(flag))
        {
            numDiff++;
        }
        //reset the flag
        flag = false;
    }
    printf("---%d---\n", numDiff);
    return numDiff;
}

List *getMinChangeDifferential(List *ladders)
{
    Node *curr = ladders->head;
    Node *next = ladders->head->next;
    List *differentials = initializeList(dummy_print, free, dummy_compare);
    forall(ladders->length - 1)
    {
        Ladder *l1 = curr->data;
        Ladder *l2 = next->data;
        int diff = calMinChangeDifferential(l1->bars, l2->bars, l1->numBars, l2->numBars);
        int* dd = calloc(1, sizeof(int));
        *dd = diff;
        insertBack(differentials, dd);
        curr = next;
        next = next->next;
    }
    for (Node *h = differentials->head; h != NULL; h = h->next)
    {
        int *d = h->data;
        printf("%d\n", *d);
    }
    return differentials;
}