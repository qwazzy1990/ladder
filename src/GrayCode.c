#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "utilities.h"
#include "Zaks.h"
#include "Sjt.h"
#include "Heaps.h"
#include "lexicographic.h"
#include "ladder.h"
#include "GrayCode.h"
#include "LinkedListAPI.h"



void runGrayCode( int upperLmit )
{
      SAVEALL = true;
      for(int i = 2; i < upperLmit; i++)
      {
          printf("\n----INPUT: %d:----\n", i+1);
          grayCodeDriver(i+1);
      }
}
void grayCodeDriver(int n)
{
    //step 1: generate permutations of size N with
    //the four different algorithms

    List* metaListOne = initializeList(dummy_print, freeList, dummy_compare);
    List* metaListTwo = initializeList(dummy_print, freeList, dummy_compare);
    List* metaListThree = initializeList(dummy_print, freeList, dummy_compare);
    List* metaListFour = initializeList(dummy_print, freeList, dummy_compare);

    //all perms generated by SJT algorithm
    List* sjtPerms = sjtGrayCodeDriver(n);
    
    //save all the ladders generated by SJT into a meta list
    saveLaddersOfAllPerms(metaListOne, sjtPerms, n);
   
    //for(Node* h = metaListOne->head; h != NULL; h = h->next)printAllLadders(h->data);
    
   
    //all perms generated by Heap's algorithm
    List* heapsPerms = heapsGrayCodeDriver(n);
    saveLaddersOfAllPerms(metaListTwo, heapsPerms, n);

    //all  perms generated by Zak's algorithm
    List* zaksPerms = zaksGrayCodeDriver(n);
    saveLaddersOfAllPerms(metaListThree, zaksPerms, n);

    //all perms generated by lexicographic algorithm
    List* lexPerms = lexGrayCodeDriver(n);
    saveLaddersOfAllPerms(metaListFour, lexPerms, n);

    
     //generate all the ladders from the permutations using root ladder as canonical ladder
    List *sjtLadders = genCanonicalLadders(sjtPerms, n);
    //generate all ladders using greedy choice for canonical ladder
    List* sjtLaddersTwo = canonicalList(metaListOne);
   
   
    freeList(metaListOne);

//generate all the ladders from the permutations using root ladder as canonical ladder
    List *heapsLadders = genCanonicalLadders(heapsPerms, n);
   
    //gen all ladders using greedy choice for canonical ladder
    List* heapLaddersTwo = canonicalList(metaListTwo);
    freeList(metaListTwo);

    List *zaksLadders = genCanonicalLadders(zaksPerms, n);
    List* zaksLaddersTwo = canonicalList(metaListThree);
    freeList(metaListThree);
    //printAllLadders(zaksLadders);
    //printAllLadders(zaksLaddersTwo);


    List *lexLadders = genCanonicalLadders(lexPerms, n);
    List* lexLaddersTwo = canonicalList(metaListFour);
    freeList(metaListFour);   
   

    // printAllLadders(heapsLadders);
    //printAllLadders(zaksLadders);
    //printAllLadders(lexLadders);

    //get the list of insertions/deletions between each ladder for each algorithm
    List* sjtDiff = getMinChangeDifferential(sjtLadders);
   
    List* heapDiff = getMinChangeDifferential(heapsLadders);
    List* zaksDiff = getMinChangeDifferential(zaksLadders);
    List* lexDiff = getMinChangeDifferential(lexLadders);

    //get the list of swaps between  consecutive pairs of ladders
    List* sjtSwap =  getSwapDifferentials(sjtLadders);
    List* heapSwap = getSwapDifferentials(heapsLadders);
    List* zakSwap = getSwapDifferentials(zaksLadders);
    List* lexSwap = getSwapDifferentials(lexLadders);


    printf("\n-------------USING ROOT LADDER AS CANONICAL LADDER-------------\n");
        printDiff(sjtDiff, heapDiff, zaksDiff, lexDiff, 1);
        printDiff(sjtSwap, heapSwap, zakSwap, lexSwap, 0);
        freeList(sjtDiff); freeList(heapDiff); freeList(zaksDiff); freeList(lexDiff);
        freeList(sjtSwap); freeList(heapSwap); freeList(zakSwap); freeList(lexSwap);
    printf("\n--------------END OF USING ROOT LADDER AS CANONICAL LADDER-----------\n");
    
    sjtDiff = getMinChangeDifferential(sjtLaddersTwo);
    heapDiff = getMinChangeDifferential(heapLaddersTwo);
    zaksDiff = getMinChangeDifferential(zaksLaddersTwo);
    lexDiff = getMinChangeDifferential(lexLaddersTwo);

    sjtSwap = getSwapDifferentials(sjtLaddersTwo);
    heapSwap = getSwapDifferentials(heapLaddersTwo);
    zakSwap = getSwapDifferentials(zaksLaddersTwo);
    lexSwap = getSwapDifferentials(lexLaddersTwo);
    freeList(sjtLaddersTwo);
    freeList(heapLaddersTwo);
    freeList(zaksLaddersTwo);
    freeList(lexLaddersTwo);
    printf("\n-----------USING CUSTOM LADDER AS CANONICAL LADDER-----------------\n");
        printDiff(sjtDiff, heapDiff, zaksDiff, lexDiff, 1);
        printDiff(sjtSwap, heapSwap, zakSwap, lexSwap, 0);
        freeList(sjtDiff); freeList(heapDiff); freeList(zaksDiff); freeList(lexDiff);
        freeList(sjtSwap); freeList(heapSwap); freeList(zakSwap); freeList(lexSwap);
    printf("\n--------------END OF USING ROOT LADDER AS CANONICAL LADDER-----------\n");
    




    

    //FREE MEM
    freeList(sjtPerms);
    freeList(heapsPerms);
    freeList(zaksPerms);
    freeList(lexPerms);
    freeList(sjtLadders);
    freeList(heapsLadders);
    freeList(zaksLadders);
    freeList(lexLadders);
}

List* sjtGrayCodeDriver(int n)
{
    //set up the variables
    int *perm = calloc(n, sizeof(int));
    int *arr = calloc(n, sizeof(int));
    bool *direction = calloc(n, sizeof(bool));
    forall(n)
    {
        perm[x] = x + 1;
        arr[x] = 0;
        direction[x] = false;
    }

    
    
    List* perms = initializeList(dummy_print, free, dummy_compare);
    //int **perms = calloc(factorial(n), sizeof(int *));

    //call the algo
    genPermsSJT(perms, perm, n, arr, direction);

    //free the mem
    free(perm);
    free(arr);
    free(direction);

    return perms;
}

List* heapsGrayCodeDriver(int n)
{
    //set up the perms
    
    List *perms = initializeList(dummy_print, free, dummy_compare);
    
    int *perm = calloc(n, sizeof(int));
    forall(n) perm[x] = x + 1;

    //call the algo
    heaps(perms, perm, n, n-1);

    //return
    free(perm);
    return perms;
}
List* zaksGrayCodeDriver(int n)
{
    //allocate for the suffix sizes
    int *suffixSizes = calloc(1000, sizeof(int));
    forall(1000) suffixSizes[x] = -1;

    //set the suffix sizes
    suffixSize(n, suffixSizes);

    //create + set the perm, perms
    int *perm = calloc(n, sizeof(int));
   
    List* perms = initializeList(dummy_print, free, dummy_compare);
    forall(n) perm[x] = x + 1;

    //call the algo
    zaks(perms, perm, n, suffixSizes, 0);

    //free mem
    free(suffixSizes);
    free(perm);
    return perms;
}

List* lexGrayCodeDriver(int n)
{
    //set up the variables
    int *perm = calloc(n, sizeof(int));
    forall(n) perm[x] = x + 1;
    
    List* perms = initializeList(dummy_print, free, dummy_compare);
    //call the algo
    orderedPerms(perms, perm, factorial(n), 1, n);
    free(perm);

    //return
    return perms;
}

//Ladder Driver
List *genCanonicalLadders(List* perms, int n)
{
    List *ladders = initializeList(dummy_print, destroyLadder, dummy_compare);
    int i = 1;
    for(Node* h = perms->head; h != NULL; h = h->next)
    {

        Ladder *l = newLadder(n);
        initLadder(l);
        int * perm = h->data;
        createRoot(l, perm, n, 0);
        l->ladderNumber = i;
        insertBack(ladders, l);
        i++;
    }
    return ladders;
}

int calMinChangeDifferential(Bar **firstBars, Bar **secondBars, int lenOne, int lenTwo)
{
    int numDiff = 0;
    if (lenOne == 0)
        return lenTwo - lenOne;
    if (lenTwo == 0)
        return lenOne - lenTwo;
    bool flag = false;
   
   
    //go through first array of bars
    for (int i = 0; i < lenOne; i++)
    {
        //get the bar
        Bar *b1 = firstBars[i];

        //go through second array of bars
        for (int j = 0; j < lenTwo; j++)
        {
            //et the bar
            Bar *b2 = secondBars[j];

            //if they are the same, then there is no difference between b1 and b2.
            if (b1->vals[0] == b2->vals[0] && b1->vals[1] == b2->vals[1])
            {
                flag = true;
                break;
            }
        }
        //if there was no matching bar, b2, with b1, then there is a difference
        if (!(flag))
        {
            numDiff++;
        }
        //reset the flag
        flag = false;
    }

      //go through first array of bars
    for (int i = 0; i < lenTwo; i++)
    {
        //get the bar
        Bar *b1 = secondBars[i];

        //go through second array of bars
        for (int j = 0; j < lenOne; j++)
        {
            //et the bar
            Bar *b2 = firstBars[j];

            //if they are the same, then there is no difference between b1 and b2.
            if (b1->vals[0] == b2->vals[0] && b1->vals[1] == b2->vals[1])
            {
                flag = true;
                break;
            }
        }
        //if there was no matching bar, b2, with b1, then there is a difference
        if (!(flag))
        {
            numDiff++;
        }
        //reset the flag
        flag = false;
    }
    return numDiff;
}

List *getMinChangeDifferential(List *ladders)
{
    Node *curr = ladders->head;
    Node *next = ladders->head->next;
    List *differentials = initializeList(dummy_print, free, dummy_compare);
    forall(ladders->length - 1)
    {
        //get the two consecutive ladders
        Ladder *l1 = curr->data;
        Ladder *l2 = next->data;

        //calculate the avg diff between them
        int diff = calMinChangeDifferential(l1->bars, l2->bars, l1->numBars, l2->numBars);

        //add diff to list
        int* dd = calloc(1, sizeof(int));
        *dd = diff;
        insertBack(differentials, dd);
       
        curr = next;
        next = next->next;
    }
  
    return differentials;
}

//function returns the average amount of minimal change 
//for a set of canonical ladders generated from 
//a gray code for permutations
double calculateAverageAmntOfDiff(List* differentials)
{
    double avgDiff = 0.0;
    int sum = 0;
    int denom = differentials->length;

    //calculate the numerator
    for(Node* h = differentials->head; h!=NULL; h = h->next)
    {
        int* a = h->data;
        sum += *a;
    }
    //calc average
    avgDiff = (double)sum/(double)denom;
   
    return avgDiff;

}



//Assume that a minimal change unit is relocation of a bar.
int calSwapDifferential(Ladder* l1, Ladder* l2)
{
    Bar** b1 = l1->bars;
    Bar** b2 = l2->bars;
    int lenOne = l1->numBars;
    int lenTwo = l2->numBars;

    int numSwaps = 0;
    for(int i=0; i < lenOne; i++)
    {
        Bar* b = b1[i];
        for(int j = 0; j < lenTwo; j++)
        {
            Bar* bb = b2[j];
            if(b->vals[0] == bb->vals[0] && b->vals[1] == bb->vals[1])
            {
                //get the columns of the bars
                int numOne = b->barNum;
                int numTwo = bb->barNum;
                
                int c1 = getColIndex(l1, numOne);
                
                int c2 = getColIndex(l2, numTwo);

                //if the columns of the same bar between two consecutive ladders differs then the bar was swapped.
                //if the bar was swapped, then it was swapped with another bar meaning that numSwaps is 
                //to be cut in half
                if(c1 != c2)numSwaps++;       
                

            }
        }        
    }
    return numSwaps/2;
}


List* getSwapDifferentials(List* ladders)
{
    Node *curr = ladders->head;
    Node *next = ladders->head->next;
    List *differentials = initializeList(dummy_print, free, dummy_compare);
    forall(ladders->length - 1)
    {
        //get the two consecutive ladders
        Ladder *l1 = curr->data;
        Ladder *l2 = next->data;

        //calculate the avg diff between them
        int diff = calSwapDifferential(l1, l2);

        //add diff to list
        int* dd = calloc(1, sizeof(int));
        *dd = diff;
        insertBack(differentials, dd);
       
        curr = next;
        next = next->next;
    }
  
    return differentials;
}



void printDiff(List* sjt, List* heaps, List* zaks, List* lex, int mode)
{
    if(mode)
    {
        printf("\n\n----AVERAGE NUMBER OF INSERTIONS OR DELETIONS OF BARS BETWEEN CONSECUTIVE LADDERS----\n");
        
    }
    else
    {
        printf("\n\n----AVERAGE NUMBER OF SWAPS OF BARS BETWEEN CONSECUTIVE LADDERS----\n");
    }
    printf("SJT: %f\nHEAPS: %f\nZAKS %f\nLEX: %f\n", calculateAverageAmntOfDiff(sjt), calculateAverageAmntOfDiff(heaps), calculateAverageAmntOfDiff(zaks), calculateAverageAmntOfDiff(lex));
   
}

void saveLaddersOfAllPerms(List* metaList, List* allPerms, int n)
{
    for(Node* h = allPerms->head; h != NULL; h = h->next)
    {
        saveAllLadders((int*)h->data, n);
        //List* newList = copyListOfLadders(allLadders);
        insertBack(metaList, copyListOfLadders(allLadders));
        freeList(allLadders);
    }
}


//find the next ladder best suited for the gray code
Ladder* getCanonicalLadder(Ladder* currLadder, List* candiateLadders, int* optChange)
{
    Ladder* candiateLadder = NULL;
    int minDiff = 1000000;
    for(Node* h = candiateLadders->head; h != NULL; h = h->next)
    {
        int numSwaps = calSwapDifferential(currLadder, h->data);
        Ladder* l2 = h->data;
        int numDiff = calMinChangeDifferential(currLadder->bars, l2->bars, currLadder->numBars, l2->numBars);
        if((numSwaps + numDiff) < minDiff)
        {
            minDiff = numSwaps + numDiff;
            candiateLadder = l2;
        }

    }
    *optChange = minDiff;
    return candiateLadder;
}

List* canonicalList(List* metaList)
{
    List* canonicalList = initializeList(dummy_print, destroyClone, dummy_compare);
    
    int optChange = 0;
    Ladder* c = NULL;
    for(Node* h = metaList->head; h != NULL; h = h->next)
    {
        

        if(h == metaList->head)
        {
            List* temp = h->data;
            //printLadder(temp->head->data);
            c = cloneLadder(temp->head->data);
            insertBack(canonicalList, c);
            // printf("---Optimal Change %d---\n", optChange);
            // printLadder(c);

        }
        else 
        {
            Ladder* canonical = getCanonicalLadder(c, h->data, &optChange);
            insertBack(canonicalList, cloneLadder(canonical));
            c = canonical;
            // printf("---Optimal Change %d---\n", optChange);
            // printLadder(canonical);
        }
    }

    return canonicalList;
}