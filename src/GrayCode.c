#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "utilities.h"
#include "Zaks.h"
#include "Sjt.h"
#include "Heaps.h"
#include "lexicographic.h"
#include "ladder.h"
#include "GrayCode.h"
#include "LinkedListAPI.h"

void grayCodeDriver(int n)
{
    //step 1: generate permutations of size N with
    //the four different algorithms

    //all perms generated by SJT algorithm
    int **sjtPerms = sjtGrayCodeDriver(n);

    //all perms generated by Heap's algorithm
    int **heapsPerms = heapsGrayCodeDriver(n);

    //all  perms generated by Zak's algorithm
    int **zaksPerms = zaksGrayCodeDriver(n);

    //all perms generated by lexicographic algorithm
    int **lexPerms = lexGrayCodeDriver(n);

    //generate all the ladders from the permutations
    List *sjtLadders = genCanonicalLadders(sjtPerms, n);

    List *heapsLadders = genCanonicalLadders(heapsPerms, n);
    List *zaksLadders = genCanonicalLadders(zaksPerms, n);
    List *lexLadders = genCanonicalLadders(lexPerms, n);

    printAllLadders(sjtLadders);
    getSwapDifferentials(sjtLadders);
    

    // printAllLadders(heapsLadders);
    //printAllLadders(zaksLadders);
    //printAllLadders(lexLadders);

    //get the list of minimal changes between each ladder for each algorithm
    List* sjtDiff = getMinChangeDifferential(sjtLadders);
   
    List* heapDiff = getMinChangeDifferential(heapsLadders);
    List* zaksDiff = getMinChangeDifferential(zaksLadders);
    List* lexDiff = getMinChangeDifferential(lexLadders);

    printf("Sjt: %f  Heap: %f  Zaks: %f  Lex: %f\n", calculateAverageAmntOfDiff(sjtDiff), calculateAverageAmntOfDiff(heapDiff), calculateAverageAmntOfDiff(zaksDiff), calculateAverageAmntOfDiff(lexDiff) );



    //freeMem
    forall(factorial(n))
    {
        free(sjtPerms[x]);
        free(heapsPerms[x]);
        free(zaksPerms[x]);
        free(lexPerms[x]);
    }
    free(sjtPerms);
    free(heapsPerms);
    free(zaksPerms);
    free(lexPerms);
    freeList(sjtLadders);
    freeList(heapsLadders);
    freeList(zaksLadders);
    freeList(lexLadders);
}

int **sjtGrayCodeDriver(int n)
{
    //set up the variables
    int *perm = calloc(n, sizeof(int));
    int *arr = calloc(n, sizeof(int));
    bool *direction = calloc(n, sizeof(int));
    forall(n)
    {
        perm[x] = x + 1;
        arr[x] = 0;
        direction[x] = false;
    }

    int **perms = calloc(factorial(n), sizeof(int *));
    forall(factorial(n)) perms[x] = NULL;

    //call the algo
    genPermsSJT(perms, perm, n, arr, direction);

    //free the mem
    free(perm);
    free(arr);
    free(direction);

    return perms;
}

int **heapsGrayCodeDriver(int n)
{
    //set up the perms
    int **perms = calloc(factorial(n), sizeof(int *));
    int *perm = calloc(n, sizeof(int));
    forall(n) perm[x] = x + 1;
    forall(factorial(n)) perms[x] = NULL;

    //call the algo
    heaps(perms, perm, n, n);

    //return
    free(perm);
    return perms;
}

int **zaksGrayCodeDriver(int n)
{
    //allocate for the suffix sizes
    int *suffixSizes = calloc(1000000, sizeof(int));
    forall(1000000) suffixSizes[x] = -1;

    //set the suffix sizes
    suffixSize(n, suffixSizes);

    //create + set the perm, perms
    int *perm = calloc(n, sizeof(int));
    int **perms = calloc(factorial(n), sizeof(int *));
    forall(factorial(n)) perms[x] = NULL;
    forall(n) perm[x] = x + 1;

    //call the algo
    zaks(perms, perm, n, suffixSizes, 0);

    //free mem
    free(suffixSizes);
    free(perm);
    return perms;
}

int **lexGrayCodeDriver(int n)
{
    //set up the variables
    int *perm = calloc(n, sizeof(int));
    forall(n) perm[x] = x + 1;
    new_object(int **, perms, factorial(n));
    forall(factorial(n)) perms[x] = NULL;

    //call the algo
    orderedPerms(perms, perm, factorial(n), 1, n);
    free(perm);

    //return
    return perms;
}

//Ladder Driver
List *genCanonicalLadders(int **perms, int n)
{
    List *ladders = initializeList(dummy_print, destroyLadder, dummy_compare);

    forall(factorial(n))
    {

        Ladder *l = newLadder(n);
        initLadder(l);
        createRoot(l, perms[x], n, 0);
        l->ladderNumber = x + 1;
        insertBack(ladders, l);
    }
    return ladders;
}

int calMinChangeDifferential(Bar **firstBars, Bar **secondBars, int lenOne, int lenTwo)
{
    int numDiff = 0;
    if (lenOne == 0)
        return lenTwo - lenOne;
    if (lenTwo == 0)
        return lenOne - lenTwo;
    bool flag = false;
   
   
    //go through first array of bars
    for (int i = 0; i < lenOne; i++)
    {
        //get the bar
        Bar *b1 = firstBars[i];

        //go through second array of bars
        for (int j = 0; j < lenTwo; j++)
        {
            //et the bar
            Bar *b2 = secondBars[j];

            //if they are the same, then there is no difference between b1 and b2.
            if (b1->vals[0] == b2->vals[0] && b1->vals[1] == b2->vals[1])
            {
                flag = true;
                break;
            }
        }
        //if there was no matching bar, b2, with b1, then there is a difference
        if (!(flag))
        {
            numDiff++;
        }
        //reset the flag
        flag = false;
    }

      //go through first array of bars
    for (int i = 0; i < lenTwo; i++)
    {
        //get the bar
        Bar *b1 = secondBars[i];

        //go through second array of bars
        for (int j = 0; j < lenOne; j++)
        {
            //et the bar
            Bar *b2 = firstBars[j];

            //if they are the same, then there is no difference between b1 and b2.
            if (b1->vals[0] == b2->vals[0] && b1->vals[1] == b2->vals[1])
            {
                flag = true;
                break;
            }
        }
        //if there was no matching bar, b2, with b1, then there is a difference
        if (!(flag))
        {
            numDiff++;
        }
        //reset the flag
        flag = false;
    }
    return numDiff;
}

List *getMinChangeDifferential(List *ladders)
{
    Node *curr = ladders->head;
    Node *next = ladders->head->next;
    List *differentials = initializeList(dummy_print, free, dummy_compare);
    forall(ladders->length - 1)
    {
        //get the two consecutive ladders
        Ladder *l1 = curr->data;
        Ladder *l2 = next->data;

        //calculate the avg diff between them
        int diff = calMinChangeDifferential(l1->bars, l2->bars, l1->numBars, l2->numBars);

        //add diff to list
        int* dd = calloc(1, sizeof(int));
        *dd = diff;
        insertBack(differentials, dd);
       
        curr = next;
        next = next->next;
    }
  
    return differentials;
}

//function returns the average amount of minimal change 
//for a set of canonical ladders generated from 
//a gray code for permutations
double calculateAverageAmntOfDiff(List* differentials)
{
    double avgDiff = 0.0;
    int sum = 0;
    int denom = differentials->length;

    //calculate the numerator
    for(Node* h = differentials->head; h!=NULL; h = h->next)
    {
        int* a = h->data;
        sum += *a;
    }
    //calc average
    avgDiff = (double)sum/(double)denom;
   
    return avgDiff;

}



//Assume that a minimal change unit is relocation of a bar.
int calSwapDifferential(Ladder* l1, Ladder* l2)
{
    Bar** b1 = l1->bars;
    Bar** b2 = l2->bars;
    int lenOne = l1->numBars;
    int lenTwo = l2->numBars;

    int numSwaps = 0;
    for(int i=0; i < lenOne; i++)
    {
        Bar* b = b1[i];
        for(int j = 0; j < lenTwo; j++)
        {
            Bar* bb = b2[j];
            if(b->vals[0] == bb->vals[0] && b->vals[1] == bb->vals[1])
            {
                //get the columns of the bars
                int numOne = b->barNum;
                int numTwo = bb->barNum;
                
                int c1 = getColIndex(l1, numOne);
                
                int c2 = getColIndex(l2, numTwo);

                //if the columns of the same bar between two consecutive ladders differs then the bar was swapped.
                //if the bar was swapped, then it was swapped with another bar meaning that numSwaps is 
                //to be cut in half
                if(c1 != c2)numSwaps++;       
                

            }
        }        
    }
    return numSwaps/2;
}


List* getSwapDifferentials(List* ladders)
{
    Node *curr = ladders->head;
    Node *next = ladders->head->next;
    List *differentials = initializeList(dummy_print, free, dummy_compare);
    forall(ladders->length - 1)
    {
        //get the two consecutive ladders
        Ladder *l1 = curr->data;
        Ladder *l2 = next->data;

        //calculate the avg diff between them
        int diff = calSwapDifferential(l1, l2);

        //add diff to list
        int* dd = calloc(1, sizeof(int));
        *dd = diff;
        insertBack(differentials, dd);
       
        curr = next;
        next = next->next;
    }
  
    return differentials;
}

